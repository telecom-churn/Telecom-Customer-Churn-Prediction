# -*- coding: utf-8 -*-
"""ML Mini Project Customer Churn Classification |ML(LogRe+XGBoost)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aFHUU371bigf8KkvfLul7vzZGSUL6K7j

## Customer Churn Classification Using ML Models
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import warnings
warnings.filterwarnings('ignore')

"""## Read & Explore Data"""

df = pd.read_csv('/content/WA_Fn-UseC_-Telco-Customer-Churn.csv')

df.head(10)

df.info()

df.shape

df.duplicated().sum()

gender_count= df['gender'].value_counts()
gender_count

"""## EDA"""

churned_customers = df[df['Churn'] == 'Yes']
churned_customers

churned_by_gender = churned_customers.groupby('gender').size().reset_index(name='Total Churned')
churned_by_gender

"""## Insights for customer Churn"""

plt.figure(figsize=(8, 6))
sns.barplot(x='gender', y='Total Churned', data=churned_by_gender, palette='viridis')
plt.title('Total Churned Customers by Gender')
plt.xlabel('Gender')
plt.ylabel('Number of Churned Customers')
plt.show()

churned_by_partner = churned_customers['Partner'].value_counts()
churned_by_partner

plt.figure(figsize=(8, 6))
plt.pie(churned_by_partner, labels=churned_by_partner.index, autopct='%1.1f%%', colors=['#66b3ff','#99ff99'], startangle=90)
plt.title('Churned Customers: Partner vs No Partner')
plt.axis('equal')
plt.show()

payment_count = churned_customers['PaymentMethod'].value_counts()
payment_count

plt.figure(figsize=(8,6))
ax = sns.barplot(x=payment_count.index,y=payment_count.values,palette='Set2')
for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                xytext=(0, 9),
                textcoords='offset points')

plt.title('Chrun customer by payment Methods')
plt.xlabel('Payment Method')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

contract_count = churned_customers['Contract'].value_counts()
contract_count

plt.figure(figsize=(8,6))
ax = sns.barplot(x=contract_count.index,y=contract_count.values,palette='Set2')
for p in ax.patches:
    ax.annotate(f'{int(p.get_height())}',
                (p.get_x() + p.get_width() / 2., p.get_height()),
                ha='center', va='center',
                xytext=(0, 9),
                textcoords='offset points')

plt.title('Chrun customer by Contract Type')
plt.xlabel('Contract Type')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

churned_customers['tenure'].unique()

bins = [0, 6, 12, 18, 24, churned_customers['tenure'].max()]
labels = ['0-6 Months', '6-12 Months', '12-18 Months', '18-24 Months', '>24 Months']
churned_customers['tenure_group'] = pd.cut(churned_customers['tenure'], bins=bins, labels=labels)

grouped = churned_customers.groupby('tenure_group').size().reset_index(name='total_churned_customers')
grouped

plt.figure(figsize=(8,6))
sns.barplot(x='tenure_group', y='total_churned_customers', data=grouped, palette='Blues_d')

for p in plt.gca().patches:
    plt.gca().annotate(f'{int(p.get_height())}',
                       (p.get_x() + p.get_width() / 2., p.get_height()),
                       ha='center', va='center', xytext=(0, 9),
                       textcoords='offset points')

plt.title('Total Churned Customers by Tenure Group', fontsize=16)
plt.xlabel('Tenure Group', fontsize=12)
plt.ylabel('Total Churned Customers', fontsize=12)
plt.xticks(rotation=45)
plt.show()

InternetService_count =  churned_customers['InternetService'].value_counts()
InternetService_count

plt.figure(figsize=(8, 6))
plt.pie(InternetService_count, labels=None, autopct='%1.1f%%', colors=['#FC8A15','#009378','#F6F6F6'], startangle=90)
plt.legend(InternetService_count.index, title="Internet Service", loc="best")
plt.title('Churned Customers by InternetService')
plt.axis('equal')
plt.show()

df['TotalCharges'] = pd.to_numeric(df['TotalCharges'], errors='coerce')

churned_customers = df[df['Churn'] == 'Yes']

plt.figure(figsize=(8, 6))
sns.histplot(churned_customers['MonthlyCharges'], bins=30, kde=True)
plt.title('Distribution of Monthly Charges for Churned Customers')
plt.xlabel('Monthly Charges')
plt.ylabel('Frequency')
plt.show()

plt.figure(figsize=(8, 6))
sns.histplot(churned_customers['TotalCharges'], bins=30, kde=True)
plt.title('Distribution of Total Charges for Churned Customers')
plt.xlabel('Total Charges')
plt.ylabel('Frequency')
plt.show()

plt.figure(figsize=(8, 6))
plt.scatter(churned_customers['MonthlyCharges'], churned_customers['TotalCharges'])
plt.title('Monthly Charges vs Total Charges for Churned Customers')
plt.xlabel('Monthly Charges')
plt.ylabel('Total Charges')
plt.show()

"""## Data Preprocessing"""

df['MultipleLines'].value_counts()

df['MultipleLines'] = df['MultipleLines'].replace('No phone service', 'No')

service_columns = [
    'PhoneService', 'MultipleLines', 'InternetService',
    'OnlineSecurity', 'OnlineBackup', 'DeviceProtection',
    'TechSupport', 'StreamingTV', 'StreamingMovies',
    'PaperlessBilling'
]

plt.figure(figsize=(15, 20))

for i, col in enumerate(service_columns, 1):
    plt.subplot(5, 2, i)
    sns.countplot(data=df, x=col, hue='Churn')
    plt.title(f'{col} vs Churn')
    plt.xlabel('')
    plt.ylabel('Count')

plt.tight_layout()
plt.show()

df.replace('No internet service', 'No', inplace=True)

df.drop('customerID',axis=1,inplace=True)

df.drop('gender',axis=1,inplace=True)

df.head()

df.info()

numerical_features = ['MonthlyCharges', 'TotalCharges',]

plt.figure(figsize=(12, 6))

for i, feature in enumerate(numerical_features, 1):
    plt.subplot(1, len(numerical_features), i)
    sns.boxplot(data=df, x=feature)
    plt.title(f'Box Plot of {feature}')

plt.tight_layout()
plt.show()

def replace_yes_no(df, columns):

    for col in columns:
        df[col] = df[col].replace({'Yes': 1, 'No': 0})

columns_to_replace = [
    "Partner", "Dependents", "PhoneService", "OnlineSecurity", "OnlineBackup",
    "DeviceProtection", "TechSupport", "StreamingTV", "StreamingMovies",
    "PaperlessBilling", "Churn"
]

replace_yes_no(df, columns_to_replace)

df.head()

from sklearn.preprocessing import LabelEncoder

labelencoder = LabelEncoder()
columns = ["MultipleLines", "Contract", "PaymentMethod", "InternetService"]

for column in columns:
    df[column] = labelencoder.fit_transform(df[column])

df.head()

df.info()

df.isna().sum()

df['TotalCharges'].fillna(value=df['TotalCharges'],inplace=True)

df = df.dropna()
df.isna().sum()

"""## Build Models"""

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from xgboost import XGBClassifier
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score, confusion_matrix, ConfusionMatrixDisplay, classification_report, precision_score, recall_score, f1_score, roc_auc_score, roc_curve
from sklearn.metrics import roc_curve
from imblearn.over_sampling import SMOTE

X = df.drop(columns=['Churn'])
y = df['Churn']

smote = SMOTE(random_state=42)
 X_res, y_res = smote.fit_resample(X, y)

X_train, X_test, y_train, y_test = train_test_split(X_res, y_res, test_size=0.2, random_state=42)

def evaluate_model(model, X_test, y_test, model_name):
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    precision = precision_score(y_test, y_pred)
    recall = recall_score(y_test, y_pred)
    f1 = f1_score(y_test, y_pred)

    print(f'{model_name} Accuracy: {accuracy:.2f}')
    print(f'{model_name} Precision: {precision:.2f}')
    print(f'{model_name} Recall: {recall:.2f}')
    print(f'{model_name} F1-Score: {f1:.2f}')



    conf_matrix = confusion_matrix(y_test, y_pred)
    print(f'{model_name} Confusion Matrix:\n{conf_matrix}')

    disp = ConfusionMatrixDisplay(confusion_matrix=conf_matrix, display_labels=['No Churn', 'Churn'])
    disp.plot(cmap='Blues')
    plt.title(f'{model_name} Confusion Matrix')
    plt.show()

"""## LogisticRegression"""

log_reg = LogisticRegression(max_iter=1000, random_state=42)
log_reg.fit(X_train ,y_train)

print("\nLogistic Regression Results:")
evaluate_model(log_reg, X_test, y_test, "Logistic Regression")

"""## RandomForest"""

rf = RandomForestClassifier(random_state=42)
rf.fit(X_train, y_train)

print("\nRandom Forest Results:")
evaluate_model(rf, X_test, y_test, "Random Forest")

"""## XGBoost"""

xgb = XGBClassifier(use_label_encoder=False, eval_metric='mlogloss', random_state=42)
xgb.fit(X_train, y_train)

print("\nXGBoost Results:")
evaluate_model(xgb, X_test, y_test, "XGBoost")

"""## Support Vector Machine"""

svm_model = SVC(kernel='linear', random_state=42)
svm_model.fit(X_train, y_train)

print("\nSVM Results:")
evaluate_model(svm_model, X_test, y_test, "SVM")